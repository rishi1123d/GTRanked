"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/vote/page",{

/***/ "(app-pages-browser)/./lib/elo.ts":
/*!********************!*\
  !*** ./lib/elo.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateElo: function() { return /* binding */ calculateElo; },\n/* harmony export */   calculateEloWithOutcome: function() { return /* binding */ calculateEloWithOutcome; },\n/* harmony export */   getInitialElo: function() { return /* binding */ getInitialElo; }\n/* harmony export */ });\n/**\n * Calculate new ELO ratings for two players after a match\n * @param winnerRating Current ELO rating of the winner\n * @param loserRating Current ELO rating of the loser\n * @param kFactor K-factor determines how much ratings change (default: 32)\n * @returns Object with new ratings for both players\n */ function calculateElo(winnerRating, loserRating) {\n    let kFactor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 32;\n    // Calculate expected scores (probability of winning)\n    const expectedWinner = 1 / (1 + Math.pow(10, (loserRating - winnerRating) / 400));\n    const expectedLoser = 1 / (1 + Math.pow(10, (winnerRating - loserRating) / 400));\n    // Calculate new ratings\n    // Winner gets 1 for winning, loser gets 0 - standard ELO formula\n    const newWinnerRating = Math.round(winnerRating + kFactor * (1 - expectedWinner));\n    const newLoserRating = Math.round(loserRating + kFactor * (0 - expectedLoser));\n    return {\n        winner: newWinnerRating,\n        loser: newLoserRating\n    };\n}\n/**\n * Calculate ELO rating updates for two players based on actual outcome\n * @param playerARating Rating of first player\n * @param playerBRating Rating of second player\n * @param outcome 1 if A wins, 0 if B wins, 0.5 for draw\n * @param kFactor K-factor determines how much ratings change (default: 32)\n * @returns Object with new ratings for both players\n */ function calculateEloWithOutcome(playerARating, playerBRating, outcome) {\n    let kFactor = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 32;\n    // Calculate expected scores (probability of winning)\n    const expectedA = 1 / (1 + Math.pow(10, (playerBRating - playerARating) / 400));\n    const expectedB = 1 / (1 + Math.pow(10, (playerARating - playerBRating) / 400));\n    // Calculate new ratings\n    const newPlayerARating = Math.round(playerARating + kFactor * (outcome - expectedA));\n    const newPlayerBRating = Math.round(playerBRating + kFactor * (1 - outcome - expectedB));\n    return {\n        playerA: newPlayerARating,\n        playerB: newPlayerBRating\n    };\n}\n/**\n * Initialize a new ELO rating for a player\n * @returns Default starting ELO rating\n */ function getInitialElo() {\n    return 1500 // Standard starting ELO\n    ;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9lbG8udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBQ00sU0FBU0EsYUFBYUMsWUFBb0IsRUFBRUMsV0FBbUI7UUFBRUMsVUFBQUEsaUVBQVU7SUFDaEYscURBQXFEO0lBQ3JELE1BQU1DLGlCQUFpQixJQUFLLEtBQUlDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNKLGNBQWNELFlBQVcsSUFBSyxJQUFHO0lBQy9FLE1BQU1NLGdCQUFnQixJQUFLLEtBQUlGLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNMLGVBQWVDLFdBQVUsSUFBSyxJQUFHO0lBRTlFLHdCQUF3QjtJQUN4QixpRUFBaUU7SUFDakUsTUFBTU0sa0JBQWtCSCxLQUFLSSxLQUFLLENBQUNSLGVBQWVFLFVBQVcsS0FBSUMsY0FBYTtJQUM5RSxNQUFNTSxpQkFBaUJMLEtBQUtJLEtBQUssQ0FBQ1AsY0FBY0MsVUFBVyxLQUFJSSxhQUFZO0lBRTNFLE9BQU87UUFDTEksUUFBUUg7UUFDUkksT0FBT0Y7SUFDVDtBQUNGO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNHLHdCQUF3QkMsYUFBcUIsRUFBRUMsYUFBcUIsRUFBRUMsT0FBZTtRQUFFYixVQUFBQSxpRUFBVTtJQUMvRyxxREFBcUQ7SUFDckQsTUFBTWMsWUFBWSxJQUFLLEtBQUlaLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNTLGdCQUFnQkQsYUFBWSxJQUFLLElBQUc7SUFDN0UsTUFBTUksWUFBWSxJQUFLLEtBQUliLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNRLGdCQUFnQkMsYUFBWSxJQUFLLElBQUc7SUFFN0Usd0JBQXdCO0lBQ3hCLE1BQU1JLG1CQUFtQmQsS0FBS0ksS0FBSyxDQUFDSyxnQkFBZ0JYLFVBQVdhLENBQUFBLFVBQVVDLFNBQVE7SUFDakYsTUFBTUcsbUJBQW1CZixLQUFLSSxLQUFLLENBQUNNLGdCQUFnQlosVUFBVyxLQUFLYSxVQUFXRSxTQUFRO0lBRXZGLE9BQU87UUFDTEcsU0FBU0Y7UUFDVEcsU0FBU0Y7SUFDWDtBQUNGO0FBRUE7OztDQUdDLEdBQ00sU0FBU0c7SUFDZCxPQUFPLEtBQUssd0JBQXdCOztBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZWxvLnRzP2E3YjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDYWxjdWxhdGUgbmV3IEVMTyByYXRpbmdzIGZvciB0d28gcGxheWVycyBhZnRlciBhIG1hdGNoXG4gKiBAcGFyYW0gd2lubmVyUmF0aW5nIEN1cnJlbnQgRUxPIHJhdGluZyBvZiB0aGUgd2lubmVyXG4gKiBAcGFyYW0gbG9zZXJSYXRpbmcgQ3VycmVudCBFTE8gcmF0aW5nIG9mIHRoZSBsb3NlclxuICogQHBhcmFtIGtGYWN0b3IgSy1mYWN0b3IgZGV0ZXJtaW5lcyBob3cgbXVjaCByYXRpbmdzIGNoYW5nZSAoZGVmYXVsdDogMzIpXG4gKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBuZXcgcmF0aW5ncyBmb3IgYm90aCBwbGF5ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVFbG8od2lubmVyUmF0aW5nOiBudW1iZXIsIGxvc2VyUmF0aW5nOiBudW1iZXIsIGtGYWN0b3IgPSAzMikge1xuICAvLyBDYWxjdWxhdGUgZXhwZWN0ZWQgc2NvcmVzIChwcm9iYWJpbGl0eSBvZiB3aW5uaW5nKVxuICBjb25zdCBleHBlY3RlZFdpbm5lciA9IDEgLyAoMSArIE1hdGgucG93KDEwLCAobG9zZXJSYXRpbmcgLSB3aW5uZXJSYXRpbmcpIC8gNDAwKSlcbiAgY29uc3QgZXhwZWN0ZWRMb3NlciA9IDEgLyAoMSArIE1hdGgucG93KDEwLCAod2lubmVyUmF0aW5nIC0gbG9zZXJSYXRpbmcpIC8gNDAwKSlcblxuICAvLyBDYWxjdWxhdGUgbmV3IHJhdGluZ3NcbiAgLy8gV2lubmVyIGdldHMgMSBmb3Igd2lubmluZywgbG9zZXIgZ2V0cyAwIC0gc3RhbmRhcmQgRUxPIGZvcm11bGFcbiAgY29uc3QgbmV3V2lubmVyUmF0aW5nID0gTWF0aC5yb3VuZCh3aW5uZXJSYXRpbmcgKyBrRmFjdG9yICogKDEgLSBleHBlY3RlZFdpbm5lcikpXG4gIGNvbnN0IG5ld0xvc2VyUmF0aW5nID0gTWF0aC5yb3VuZChsb3NlclJhdGluZyArIGtGYWN0b3IgKiAoMCAtIGV4cGVjdGVkTG9zZXIpKVxuXG4gIHJldHVybiB7XG4gICAgd2lubmVyOiBuZXdXaW5uZXJSYXRpbmcsXG4gICAgbG9zZXI6IG5ld0xvc2VyUmF0aW5nLFxuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIEVMTyByYXRpbmcgdXBkYXRlcyBmb3IgdHdvIHBsYXllcnMgYmFzZWQgb24gYWN0dWFsIG91dGNvbWVcbiAqIEBwYXJhbSBwbGF5ZXJBUmF0aW5nIFJhdGluZyBvZiBmaXJzdCBwbGF5ZXJcbiAqIEBwYXJhbSBwbGF5ZXJCUmF0aW5nIFJhdGluZyBvZiBzZWNvbmQgcGxheWVyXG4gKiBAcGFyYW0gb3V0Y29tZSAxIGlmIEEgd2lucywgMCBpZiBCIHdpbnMsIDAuNSBmb3IgZHJhd1xuICogQHBhcmFtIGtGYWN0b3IgSy1mYWN0b3IgZGV0ZXJtaW5lcyBob3cgbXVjaCByYXRpbmdzIGNoYW5nZSAoZGVmYXVsdDogMzIpXG4gKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBuZXcgcmF0aW5ncyBmb3IgYm90aCBwbGF5ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVFbG9XaXRoT3V0Y29tZShwbGF5ZXJBUmF0aW5nOiBudW1iZXIsIHBsYXllckJSYXRpbmc6IG51bWJlciwgb3V0Y29tZTogbnVtYmVyLCBrRmFjdG9yID0gMzIpIHtcbiAgLy8gQ2FsY3VsYXRlIGV4cGVjdGVkIHNjb3JlcyAocHJvYmFiaWxpdHkgb2Ygd2lubmluZylcbiAgY29uc3QgZXhwZWN0ZWRBID0gMSAvICgxICsgTWF0aC5wb3coMTAsIChwbGF5ZXJCUmF0aW5nIC0gcGxheWVyQVJhdGluZykgLyA0MDApKVxuICBjb25zdCBleHBlY3RlZEIgPSAxIC8gKDEgKyBNYXRoLnBvdygxMCwgKHBsYXllckFSYXRpbmcgLSBwbGF5ZXJCUmF0aW5nKSAvIDQwMCkpXG4gIFxuICAvLyBDYWxjdWxhdGUgbmV3IHJhdGluZ3NcbiAgY29uc3QgbmV3UGxheWVyQVJhdGluZyA9IE1hdGgucm91bmQocGxheWVyQVJhdGluZyArIGtGYWN0b3IgKiAob3V0Y29tZSAtIGV4cGVjdGVkQSkpXG4gIGNvbnN0IG5ld1BsYXllckJSYXRpbmcgPSBNYXRoLnJvdW5kKHBsYXllckJSYXRpbmcgKyBrRmFjdG9yICogKCgxIC0gb3V0Y29tZSkgLSBleHBlY3RlZEIpKVxuICBcbiAgcmV0dXJuIHtcbiAgICBwbGF5ZXJBOiBuZXdQbGF5ZXJBUmF0aW5nLFxuICAgIHBsYXllckI6IG5ld1BsYXllckJSYXRpbmcsXG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IEVMTyByYXRpbmcgZm9yIGEgcGxheWVyXG4gKiBAcmV0dXJucyBEZWZhdWx0IHN0YXJ0aW5nIEVMTyByYXRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEluaXRpYWxFbG8oKSB7XG4gIHJldHVybiAxNTAwIC8vIFN0YW5kYXJkIHN0YXJ0aW5nIEVMT1xufVxuXG4iXSwibmFtZXMiOlsiY2FsY3VsYXRlRWxvIiwid2lubmVyUmF0aW5nIiwibG9zZXJSYXRpbmciLCJrRmFjdG9yIiwiZXhwZWN0ZWRXaW5uZXIiLCJNYXRoIiwicG93IiwiZXhwZWN0ZWRMb3NlciIsIm5ld1dpbm5lclJhdGluZyIsInJvdW5kIiwibmV3TG9zZXJSYXRpbmciLCJ3aW5uZXIiLCJsb3NlciIsImNhbGN1bGF0ZUVsb1dpdGhPdXRjb21lIiwicGxheWVyQVJhdGluZyIsInBsYXllckJSYXRpbmciLCJvdXRjb21lIiwiZXhwZWN0ZWRBIiwiZXhwZWN0ZWRCIiwibmV3UGxheWVyQVJhdGluZyIsIm5ld1BsYXllckJSYXRpbmciLCJwbGF5ZXJBIiwicGxheWVyQiIsImdldEluaXRpYWxFbG8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/elo.ts\n"));

/***/ })

});